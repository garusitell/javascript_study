## 표현식과 연산자
#### 작성 : hyunjin4270
**작성 날짜 : 2024-05-22**

---

#### 4.1 기본표현식

가장 간단한 표현식을 기본표현식이라 부른다. 자바스크립트의 기본 표현식 은 상수나 리터럴 값, 일부 키워드, 변수참조가 있다.
```JavaScript
1.23    // 숫자 리터럴
"Hello" // 문자열 리터럴
true    // 불리언 리터럴
null    // null 리터럴
sum     // 변수 리터럴
```
<br/>

#### 4.2 객체와 배열 초기화 표현식

객체와 배열의 초기화 표현식은 그 값이 새로 생성된 객체나 배열인 표현식이다
이런 초기화 표현식을 객체 리터럴이나 배열 리터럴이라고 부르기도 한다
하지만 리터럴과 달리 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성되므로 기본 표현식은 아니다

배열 초기화 표현식은 대괄호 안에 컴마로 구분된 리스트를 쓰는 형태의 표현식이다
```JavaScript
let a = [3, 7]; //요소가 두 개인 배열
let b = [[1, 2], [3, 4], [5, 6]]; // 요소가 3개 있는 배열 안에 있는 요소가 2개 있는 배열
let c = { x: 2.3, y: -1.2}; //프로퍼티가 두 개 있는 객체
let d = []; // 요소가 없는 빈 배열
let e = {}; // 프로퍼티가 없는 빈 배열
```
<br/>

#### 4.3 함수 정의 표현식

함수 정의 표현식은 함수를 정의하며 그 값은 함수다.
객체 초기화 표현식을 객체 리터럴이라고 부르기도 하니, 같은 방식으로 함수 정의 표현식을 함수리터럴이라고도 부른다
```JavaScript
let func = function() { return x * x; };
```
<br/>

#### 4.4 프로퍼티 접근 표현식

프로퍼티 접근 표현식은 객체 프로퍼티나 배열 요소의 값으로 평가된다.
프로퍼티 접근 문법은 총 2가지가 있다.
```JavaScript
expression.identifier   //객체를 나타내고 식별자는 원하는 프로퍼티 이름이다
expression [expression] //프로퍼티 이름이나 배열 요소 인덱스다
```
다음 예제를 통해 자세히 알아보자
let o = {x: 1, y: {z: 3}};
let a = [o, 4, [5, 6]];
```JavaScript
o.x         // 1: 표현식 o의 포로퍼티 x
o.y.z       // 3: 표현식 o.y의 포로퍼티 z
o["x"]      // 1: 객체 o의 프로퍼티 x
a[1]        // 4: 표현식 a의 인덱스 1에 있는 요소
a[2]["1"]   // 6: 표현식 a[2]의 인덱스 1에 있는 요소
a[0].x      // 1: 표현식 a[0]의 프로퍼티 x
```
만약 코드에 있는 경로에 값이 null이나 indefined면 이 둘은 프로퍼티를 가질 수 없는 값이므로 TypeError를 일으킨다.
이러한 TypeError를 방지하기 위해 ES2020부터 조건부 프로퍼티 접근이 가능하도록 새로운 프로퍼티 접근 표현식을 두 가지를 추가했다.
```JavaScript
expression?.identifier
expression?.[expression]
```
?.와 ?.[] 문법을 사용해 TypeError를 일으키지 않고 indefined로 결과를 낸다.
```JavaScript
let a = {b:{}};
console.log(a.b?.c?.d);   // undefined
```
다음과 같은 예제가 있다. 이와 같은 경우 a는 a.b까지는 경로가 있지만 c.d는 없기에 c를 접근하는 순간 indefined로 평가되며 b와 c 하위 표현식은 평가되지 않는다. b와 c의 표현식에 다른 부수적인 효과가 있더라도 a가 정의되지 않은 경우에는 나타나지 않는다.

```JavaScript
let a;                      // 변수 초기화를 안했다.
let index = 0;
try {
    console.log(a[index++]);// TypeError가 일어난다.
} catch(e) {
    console.log(index);     // 1: index는 TypeError가 일어나기 전에 증가했다
}
console.log(a?.[index++]);  //undefined a가 정의되지 않았다.
console.log(index);         // 1: ?.[]는 단축 평가이므로 index는 증가하지 않았다.
console.log(a[index++])     // TypeError 정의되지 않은 것에서 인덱스를 찾을 수 없다
```
<br/>

#### 4.5 호출 표현식

호출 표현식은 함수나 메서드를 호출하는 문법이다.
호출 표현식은 함수 표현식으로 시작하고 다음에 괄호를 쓰고, 컴마로 구분된 0개 이상의 함수 인자 표현식 리스트를 쓰고 괄호를 닫는 것으로 끝난다.

```JavaScript
f(0)            // f는 함수 표현식이고 0은 인자 표현식이다
Math.max(x,y,z) // Math.max는 함수이고 x, y, z는 인자다
a.sort()        // a.sort는 함수이고 인자는 없다
```

함수 표현식의 값이 함수가 아니라면 TypeError가 일어나고, 이밖에도 함수가 return문을 사용해 값을 반환한다면 그 값이 호출 표현식의 값이고, 그렇지 않다면 indefined이다.

함수 표현식도 앞서 설명한 것과 똑같이 조건부 호출이 가능하다. 모양도 비슷하게 ?.()로 호출할 수 있다.
```JavaScript
function square(x, log) {
    if (log) {
    log(x);
    }
    return x*x; // 인자의 제곱을 반환한다
}
function square(x, log) {
    log?.(x);   // 함수를 받았으면 호출한다
    return x*x; // 인자의 제곱을 반환한다
}
```

위에 있는 두 예제가 비슷해 보일 수 가 있지만 if와 달리 조건부 호출인 ?.()는 null이나 undefined인지만 체크한다는 것을 기억해야 된다.
조건부 프로퍼티 접근 표현식과 마찬가지로, ?.()를 사용한 함수 호출 역시 단축평가된다.
?. 왼쪽에 있는 값이 null이나 indefined라면 괄호 안에 있는 함수 인자 표현식은 평가되지 않는다
```JavaScript
let f = null, x = 0;
try {
    f(x++); // f가 null이면 TypeError가 일어난다
} catch(e) {
    console.log(x); // 1: x가 예외처리 되기전에 증가했다
}
f?.(x++);   //undefined: f는 null이지만 예외가 일어나진 않는다
console.log(x); // 1: 단축 평가이므로 x는 증가하지 않았다.
```
<br/>

#### 4.6 객체 생성 표현식

객체 생성 표현식은 객체를 생성하고 호출해 객체 프로퍼티를 초기화한다.
사용방법은 앞에 new 키워드를 붙이면 된다.

new Object
new Date

#### 4.7 연산자 개요

|연산자|동작|
|------|---|
|++|전위(후위) 증가|
|--|전위(후위) 감소|
|-|숫자의 부호를 변경|
|~|비트를 반대로|
|!|불리언 값을 반대로|
|delete|프로퍼티 제거|
|typeof|피연산자의 타입을 반환|
|void|undefined값을 반환|
|**|지수|
|*,/,%|곱셈, 나눗셈, 나머지|
|+,-|덧셈, 뺄셈|
|+|문자열 변합|
|<<|왼쪽 시프트|
|>>|오른쪽 시프트|
|>>>|0으로 채우는 오른쪽 시프트|
|<, <=, >, >=|숫자로 비교, 문자열을 알파벳 순서로 비교|
|instanceof|객체 클래스 체크|
|in|프로퍼티가 존재하는지 체크|
|==|동등성 체크|
|!=|비동등성 체크|
|===|일치 체크|
|!==|불일치 체크|
|&|비트 AND|
|^|비트 XOR|
|\||비트 OR|
|&&|논리 AND|
|\|\||논리 OR|
|??|첫 번째로 정의된 피연산자 선택|
|?:|두 번째 또는 세 번째 피연산자 선택|
|=|변수나 프로퍼티에 할당|
|**=, *=, /=, %=, +=, -=, &=, ^=, !=, <<=, >>=, >>>=|연산 후 할당|
<br/>

#### 4.9 관계 표현식

관계 연산자는 두 값 사이의 관계를 나타내며, 그런 관계에 따라 불리언값을 반환한다.
==와 === 연산자는 두 값이 같은지 체크하며, 서로 다른 기준을 사용한다.
숫자, 문자열, 객체 등 어떤 피연산자든 받을 수 있으며, 같을땐 true값을, 아니면 false값을 반환한다.
===는 ==와 달리 완전히 일치하는지 체크한다.
자바스크립트는 ==,===을 지원하는데 ==연산자는 자바스크립트의 구형 기능이며 많은 버그를 낳는 것으로 악명이 높다,
되도록이면 == 대신 ===를, != 대신 !==을 이용하는게 좋다.
비교 연산자는 피연산자의 순서를 비교한다,
수학기호와 똑같이 <는 미만, >는 초과, <=와 >=는 이하, 이상이다.
in 연산자는 왼쪽 피연산자가 오른쪽 객체의 프로퍼티 이름일 경우 true를 반환한다.
```JavaScript
let point = {x: 1, y:  1};  // 객체를 정의한다
"x" in poiont // true: 객체에는 "x"라는 프로퍼티가 있다.
"z" in poiont // false: 객체에는 "z"라는 프로퍼티가 없다.
"toString" in poiont   // true: 객체는 toString 메서드를 상속한다
let data = [7,8,9]; // 프로퍼티 0, 1, 2.가 있는 배열
"0" in data // true: 배열에 요소 "0"이 있다
1 in data // true: 숫자는 문자열로 변환되어 요소 "1"이 있다.
3 in data // false: 요소 "3"은 없다
```
instanceof 연산자는 왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스라면 true를, 아니면 false를 반환한다
```JavaScript
let d = new Date(); // Date() 생성자로 객체를 생성한다
d instanceof Date;  // true: d는 Date()를 통해 생성됐다
d instanceof Object;// true: 객체는 모드 Object의 인스턴스다
d instanceof Number;// false: d는 Number 객체가 없다
let a = [1, 2, 3];  // 배열 리터럴 문법으로 배열을 생성한다
a instanceof Array; // true: a는 배열이다
a instanceof Object;// true: 배열은 모두 객체다
a instanceof RegExp;// false: a는 정규표현식이 아니다 
```
<br/>

#### 4.10 논리 표현식

논리연산자 &&, ||, !는 불리언 연산을 수행한다.
```JavaScript
x === 0 && y === 0  // x와 y가 전부 0일 때 true다
x === 0 || y === 0  // x와 y중 한개라도 0일 경우, true다
!true               // false: !가 앞에 붙으면 불리언값이 반대가 된다.
```
<br/>

#### 4.11 할당 표현식

자바스크립트 말고도 여러 언어에서는 =는 equal이 아니라 할당하는 개념이다.
```JavaScript
let i = 0;      // 변수 i의 값을 0으로 할당한다
o.x = 1;        // 객체 o의 x프로퍼티에 1을 할당한다
```

할당 연산자 앞에 산술 연산자를 붙이면 바로 연산 후 할당이 가능하다
```JavaScript
a += b;     // a = a + b;
a -= b;     // a = a - b;
a *= b;     // a = a * b;
a /= b;     // a = a / b;
a %= b;     // a = a % b;
```
<br/>

#### 4.12 평가 표현식

인터프리터 언어가 대부분 그렇지만, 자바스크립트 역시 문자열을 자바스크립트 소스 코드로 해석하고 평가해서 값을 얻을 수 있다.
```JavaScript
eval("3 + 2")       // 5
```
동적으로 문자열 을 평가해 소스코드로 바꾸는 것은 지나치게 강력한 기능이여서 현실에서는 절대로 사용하지 않다.

#### 4.13 기타 연산자

위에 설명한 것 말고도 다른 연산자들이 있다.
**조건 연산자(?:)**
조건 연산자는 자바스크립트에서의 유일한 3항 연산자다.
사용방법은 다른 삼항 연산자와 비슷하다
```JavaScript
x > 0 ? x : -x;
```
**null 병합 연산자(??)**
null 병합 연산자는 ??는 정의된 첫 번째 피연산자로 평가된다. 왼쪽 피연산자가 null이나 undefined로 평가될 때만 두 번째 피연산자를 반환한다.
만약 아니면 오른쪽 피연산자를 반환한다.

```JavaScript
let options = {timeout: 0, title:"", verbose: false, n: null};
options.timeout ?? 1000; // 0
options.title ?? "Untitled"; // ""
options.verbose ?? true // false
options.quiet ?? false // false
options.n ?? 10 // 10 
```

**typeof연산자**
typeof는 단항 연산자이며 피연산자의 타입을 가리지 않는다. 값은 피연산자의 타입을 나타내는 문자일이다.
|x|typeof x|
|----|----|
|undefined|"undefined"|
|null|"object"|
|true false|"boolean"|
|숫자 또는 NaN|"number"|
|Bigint|"bigint"|
|문자열 전체|"string"|
|심볼 전체|"function"|
|함수가 아닌 객체 전체|"object"|

**delete 연산자**
delete는 피연산자로 지정된 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자다.
```JavaScript
let o = {x: 1, y: 2};
delete o.x;     //프로퍼티 중 하나를 삭제한다
"x" in o;       // false: 프로퍼티가 삭제됐기 때문에 false값을 반환한다
```

**await 연산자**
await는 자바스크립트의 비동기 프로그래밍을 더 자연스럽게 사용하기 위해 도입됐다.
await는 비동기 연산을 나타내는 프라미스 객체를 피연산자로 예상하고, 프로그램이 마치 그 비동기 연산이 끝나길 기다리는 것처럼 동작한다.

**컴마 연산자(,)**
컴마 연산자는 2항 연산자이며, 피연산자의 타입을 가리지 않는다.
이 연산자를 왼쪽 피연산자를 계산하고, 오른쪽 피연산자를 평가한 후 오른쪽 피연산자의 값을 개선한다.
```JavaScript
let i = 1, j = 2; l = 3;    // let i = 1; let j = 2; l = 3;
```
