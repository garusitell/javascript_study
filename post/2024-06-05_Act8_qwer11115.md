# 함수
- 한 번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다.
- 매개변수화되어 특정 매개변수를 받고, 이는 함수의 지역변수로 취급된다.
- 객체이며 함수를 변수에 할당하거나 다른 함수에 전달할 수 있다.

## 함수 정의

### 1. funcion 키워드

```javascript
funcion 함수이름 (매개변수){
    실행문
}
```
```javascript
funcion sum (x, y){
    var result = x + y;
    return result;
}
```
이렇게 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다.<br>
자바스크립트 인터프리터가 해당 블록의 코드를 실행하기 전에 정의된다고 봐도 된다. <br>

### 2. 함수 표현식
변수를 선언하고 함수를 대입하는 방식이다.
```javascript
const sum = funcion(x, y){
    var result = x + y;
    return result;
}
```
표현식으로 정의된 함수는 정의하기 전에 호출할 수 없으며, 함수에 이름을 붙이는 것은 선택사항이다.

### 3. 화살표 함수
```javascript
const sum = (x, y) => {return x + y;};
```
화살표 함수는 표현식에 해당된다. <br> **함수 매개변수와 => 사이에서 줄바꿈을 해서는 안된다.** <br><br>


## 함수 호출
함수 바디를 구성하는 코드는 함수를 정의할 때가 아니라 *호출할 때* 실행된다. 
### 1. 함수로 호출
```javascript
sum(1,2);
```
### 2. 메서드로 호출
**메서드**는 객체 프로퍼티로 저장된 자바스크립트 함수다.<br>
함수 f와 객체 o가 있을 때 다음과 같이 o에 메서드 m을 정의할 수 있다.
```javascript
o.m = f;
```
객체 o의 메서드 `m()`은 다음과 같이 호출한다.
```javascript
o.m();
```
### 3. 생성자로 호출
함수나 메서드를 호출할 때 앞에 키워드 `new`를 붙이면 생성자로 호출된다.
```javascript
o = new Object();
```
이렇게 호출되는 생성자 함수는 객체를 상속하는 빈 객체를 새로 생성하며, 객체를 초기화할 의도로 만들어졌다.
### 4. 간접적 호출
자바스크립트 함수는 객체이며 다른 자바스크립트 객체와 마찬가지로 메서드가 있다. 이 메서드 중 `call()`과 `apply()`는 함수를 간접적으로 호출한다.
### 5. 묵시적 함수 호출
함수 호출처럼 보이지 않지만 함수를 호출하는 기능이 여럿 존재한다.<br>
이렇게 호출한 함수에서 문제가 발생한다면 단순히 코드를 보는 것만으로는 언제 호출되는지 명확히 알기 어려우므로 일반적인 함수에 비해 해결하기 어렵기 때문에 조심해야한다. 묵시적인 함수 호출을 일으키는 언어 기능은 다음과 같다.
- 객체에 게터나 세터가 있다면 프로퍼티 값에 접근할 때 이 메서드가 호출될 수 있다.
- 문자열을 받는 컨텍스트에 객체를 사용하면 `toString()` 메서드가 호출된다. 마찬가지로 객체를 숫자 컨텍스트에 사용하면 `valueOf()` 메서드가 호출된다.
- 이터러블 객체의 요소를 순회할 때 여러가지 메서드가 호출될 수 있다.
- 태그된 템플릿 리터럴도 함수 호출을 일으킬 수 있다.
- 프록시 객체는 함수에 의해 제어된다. 이런 객체에는 어떤 동작을 취하든 항상 함수가 호출된다.


## 함수 매개변수
자바스크립트 함수는 매개변수로 어떤 타입을 받는지 정의하지 않는다. 또한 값을 전달할 때도 타입을 체크하지 않는다. 함수 인자에 뜻이 분명한 이름을 쓰고, 함수에 주석을 달아두면 도움이 된다.
- 선언된 매개변수보다 적은 인자로 함수를 호출하면, 대응하는 인자가 없는 매개변수는 기본값인 undefined로 정해진다.
- 인자 개수에 제한이 없는 함수를 **가변 함수**라고 부른다.


## 네임스페이스 함수
함수 안에서 선언한 변수는 해당 함수 안에서만 작동한다. 이를 이용해 전역 네임스페이스를 어지럽히지 않도록 임시 네임스페이스 기능을 하는 함수를 정의하는 것이 유용할 때도 있다.

> '라이브러리 파일을 여러 개 읽어들여 사용할 때, 규모가 큰 프로그램을 만들 때, 여러 사람이 한 프로그램을 만들 때' 등 이러한 상황에서 이름이 겹치는 변수 또는 함수가 있다면 오작동이 발생할 수 있다. 

함수를 네임스페이스로 사용하는 방법은 네임스페이스 안에 있는 변수를 사용해 하나 이상의 함수를 정의하고, 정의된 함수를 네임스페이스 함수의 반환 값으로 사용할 때  유용하다. 이런 함수를 **클로저**라고 부른다.

## 함수 프로퍼티, 메서드, 생성자
#### `lenth` 프로퍼티
- 읽기 전용. 정의된 매개변수 개수, 함수가 예상하는 인자 개수 <br>
#### `name` 프로퍼티
- 읽기 전용. 함수의 이름, 익명의 함수 표현식이라면 처음 생성됐을 때 할당된 변수나 프로퍼티 이름. 디버깅, 에러 메시지에 유용하게 사용됨.
#### `call()`, `apply()` 메서드
- 함수를 마치 다른 객체의 메서드인 것처럼 간접적으로 호출한다.
#### `bind()` 메서드
- 주요 목적은 함수를 객체에 결합하는 것이다. 함수 f에서 bind() 메서드를 호출하면서 객체 o를 전달하면 새 함수를 반환한다. 새 함수를 함수로 호출하면 원래 함수 f가 o의 메서드로 호출된다. 새 함수에 전달한 인자는 모두 원래 함수에 전달된다.
#### `Function()` 생성자
- 함수는 객체이므로 Function() 생성자를 통해 새 함수를 생성할 수 있다.
```javascript
const f = new Function("x", "y", "return x*y;");

// 위 코드가 생성한 함수는 다음과 같이 정의한 함수와 거의 동등하다.

const f = function(x, y) { return x*y; };
```
이 생성자가 만드는 함수는 항상 최상위 함수로 컴파일된다. 이 생성자를 사용할 일은 아마 없을거라고 한다 . . .
